/**
 * klotho generated
 * This file is generated by klotho to create the resources for your 'compiled' application and will
 * be overwritten on subsequent compilations, so do not modify. Configuration can be done via a configuration
 * file. The configuration used to generate this file has been rendered at `./{{.ConfigPath}}` which you can copy
 * and pass in to the CLI via the `--config path/to/config` flag.
 */

import * as pulumi from "@pulumi/pulumi"
import { Region, USEast1Region } from "@pulumi/aws";
import * as aws from '@pulumi/aws'
import * as awsx from '@pulumi/awsx'
import * as k8s from '@pulumi/kubernetes'
import { v4 as uuidv4 } from "uuid";
import {CloudCCLib, kloConfig} from './deploylib'
import {EksExecUnitArgs, EksExecUnit} from './iac/eks'
import {CockroachDB} from './iac/cockroachdb'
{{- if .APIGateways}}
import {ApiGateway, Gateway, Route } from './iac/api_gateway'
{{end}}
import { LoadBalancerPlugin } from './iac/load_balancing'

{{- if .StaticUnits}}
import {createStaticS3Website} from './iac/static_s3_website'
{{end}}

{{- if .CloudfrontDistributions}}
import { Cloudfront } from './iac/cloudfront'
{{end}}

export = async () => {
    const minimumNodeVersion = 16
    const nodeVersionMatch = process.version.match(/^v(\d+)/)
    if (nodeVersionMatch) {
        let nodeVersion = parseInt(nodeVersionMatch[1])
        if (nodeVersion < minimumNodeVersion) {
            console.error(`Node is at ${process.version}, but Klotho IaC requires at least v${minimumNodeVersion}.`)
            process.exit(1)
        }
    } else {
        console.warn("Couldn't find Node version. If you see other errors, Node may not be correctly set up.")
    }
    const stageName = "stage"
    const appName = "{{.AppName}}"

    const awsConfig = new pulumi.Config("aws");

    const region = awsConfig.require<Region>("region");
    const webportalUpload = kloConfig.get("webportal-upload") || "false"
    const sharedRepo = new awsx.ecr.Repository(appName, {
        repository: new aws.ecr.Repository(appName, {
            name: `${appName}-repo`,
            forceDelete: true
        })
    })
    const namespace = kloConfig.get("namespace") || "cloudccprod"

    const datadogEnabled = {{if .Datadog}}true{{else}}false{{end}}

    const topology = {{jsonPretty .Topology}}

    const createVPC = {{ .UseVPC}};

    const cloudLib = new CloudCCLib(
        sharedRepo,
        stageName,
        region,
        appName,
        namespace,
        datadogEnabled,
        "{{.PayloadsBucketName}}",
        topology,
        createVPC,
    )

    cloudLib.uploadAnalytics("Starting pulumi update", false, false)
    cloudLib.uploadAnalytics("Starting pulumi preview", true, false)

    {{- if .HasKV}}
    cloudLib.setupKV();
    {{- end}}

    {{- if .Secrets}}
    cloudLib.setupSecrets({{json .Secrets}});
    {{- end}}

    {{range $orm := .ORMs -}}
    {{if eq $orm.Type "rds_postgres" -}}
    cloudLib.setupRDS("{{$orm.Name}}", {{json $orm.Params}} as Partial<aws.rds.InstanceArgs>);
    {{- else if eq $orm.Type "cockroachdb_serverless" -}}
    cloudLib.addConnectionString(
        "{{$orm.Name}}",
        new CockroachDB("{{$orm.Name}}-db", {app: appName, id: "{{$orm.Name}}", region, topology{{if $orm.Params}}, ...{{json $orm.Params}}{{end -}} }).connectionString,
    )
    {{- end}}
    {{- end}}

    {{range $redis := .Redis -}}
    cloudLib.setupRedis("{{$redis.Name}}", "{{$redis.Type}}", {{json $redis.Params}} as Partial<aws.elasticache.ClusterArgs | aws.memorydb.ClusterArgs>);
    {{- end}}

    let keepWarm: string[] = [];

    {{- $cfg := . }}

    const lbPlugin = new LoadBalancerPlugin(cloudLib)

    {{range $unit := .ExecUnits -}}
    cloudLib.createImage("{{$unit.Name}}","{{$unit.DockerfilePath}}")
    {{end -}}


    const eksUnits: EksExecUnit[] = []
    const arUrls: any[] = [];
    {{range $unit := .ExecUnits -}}

    {{- if eq $unit.Type "ecs"}}
    cloudLib.createEcsService("{{$unit.Name}}",{{jsonPretty $unit.Params | indent 4}} as Partial<awsx.ecs.Container>, "{{ $unit.NetworkPlacement }}", {{jsonPretty $unit.EnvironmentVariables | indent 4}}, lbPlugin);
    {{else if eq $unit.Type "eks"}}
    eksUnits.push({name: "{{$unit.Name}}", params: {{jsonPretty $unit.Params | indent 4}}, helmOptions: {{jsonPretty $unit.HelmOptions | indent 4}}, network_placement: "{{ $unit.NetworkPlacement }}" {{- if $unit.EnvironmentVariables}}, envVars: {{jsonPretty $unit.EnvironmentVariables | indent 4}} {{end}}})
    {{else if eq $unit.Type "apprunner"}}
    arUrls.push(cloudLib.createDockerAppRunner("{{$unit.Name}}", {{- if $unit.EnvironmentVariables}} , {{jsonPretty $unit.EnvironmentVariables | indent 4}} {{end}}))
    {{else}}
    cloudLib.createDockerLambda("{{$unit.Name}}", {{jsonPretty $unit.Params | indent 4}} as Partial<aws.lambda.FunctionArgs>, "{{ $unit.NetworkPlacement }}" {{- if $unit.EnvironmentVariables}} , {{jsonPretty $unit.EnvironmentVariables | indent 4}} {{end}});
    {{end}}

    {{- if .KeepWarm}}
    keepWarm.push("{{$unit.Name}}");
    {{end}}
    {{range $idx, $s := .Schedules}}
    cloudLib.scheduleFunction("{{$unit.Name}}", "{{$s.ModulePath}}", "{{$s.FuncName}}}", "{{$s.Cron}}");
    {{end -}}
    {{end -}}

    {{- if .HelmCharts }}
        await cloudLib.createEksResources(eksUnits, {{jsonPretty .HelmCharts | indent 4}}, lbPlugin);
    {{else}}
    if (eksUnits.length > 0 ) {
        await cloudLib.createEksResources(eksUnits, [], lbPlugin);
    }
    {{end}}

    cloudLib.configureExecUnitPolicies()

    const staticUnitUrls: any[] = [];

    {{range $unit := .StaticUnits}}
    staticUnitUrls.push(createStaticS3Website(
    "{{$unit.Name}}", "{{$unit.IndexDocument}}", "{{$unit.ContentDeliveryNetwork.Id}}", cloudLib
    ))
    {{end}}

    const frontendUrls = staticUnitUrls;

    const apprunnerUrls = arUrls.filter(url => { return url != null});;

    const gatewayUrls: any[] = [];
    {{- if .ALBs}}
    lbPlugin.createALBasGateways({{ jsonPretty .ALBs | indent 4}})
    gatewayUrls.push(...lbPlugin.invokeUrls)
    {{end}}
    {{- if .APIGateways}}
    const apiGatewayUrls = new ApiGateway(cloudLib, lbPlugin, {{ jsonPretty .APIGateways | indent 4}})
    gatewayUrls.push(...apiGatewayUrls.invokeUrls)
    {{end}}

    const apiUrls = gatewayUrls;

    {{- if .CloudfrontDistributions}}
        new Cloudfront(cloudLib, {{jsonPretty .CloudfrontDistributions | indent 4}})
    {{end}}

    {{range $event := .PubSubs}}
    cloudLib.createTopic(
        "{{$event.Path}}", "{{$event.Name}}", "{{$event.EventName}}",
        {{if $event.Publishers }}
        {{json (keyNames $event.Publishers)}},
        {{else}}
        [],
        {{end}}
        {{if $event.Subscribers }}
        {{json (keyNames $event.Subscribers)}},
        {{else}}
        [],
        {{end}}
    )
    {{- end}}

    if (keepWarm.length > 0) {
        cloudLib.installLambdaWarmer(keepWarm);
    }

    cloudLib.createPolicy();

    let url = `None - Opted out of topology upload by default`;

    if (webportalUpload == "true") {
        const id = `${pulumi.getStack()}-${uuidv4()}`
        cloudLib.uploadTopologyDiagramToPortal(id);
        cloudLib.uploadTopologySpecToPortal(id);
        url = `https://app.klo.dev/dashboard/${id}`
    }
    const deploymentPortal = url;

    cloudLib.uploadAnalytics("Finished pulumi update", false, true)
    cloudLib.uploadAnalytics("Finished pulumi preview", true, false)

    return { frontendUrls, apiUrls, apprunnerUrls, deploymentPortal};
}
